"""
JWT validation middleware for FastAPI
Generated by better-auth-setup skill

Auth Server: {{AUTH_SERVER_URL}}
Database: {{DATABASE_PROVIDER}}
Validation Method: {{VALIDATION_METHOD}}
"""
from typing import Annotated

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
{{#VALIDATION_METHOD_DATABASE}}
from src.database.postgres import postgres_db
{{/VALIDATION_METHOD_DATABASE}}
{{#VALIDATION_METHOD_JWT}}
import jwt
from src.config import settings
{{/VALIDATION_METHOD_JWT}}

# HTTP Bearer token security scheme
security = HTTPBearer()


async def get_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials, Depends(security)],
) -> dict:
    """
    Validate Session Token via {{VALIDATION_METHOD}}.

    {{#VALIDATION_METHOD_DATABASE}}
    Uses direct database lookup to validate session tokens.
    No inter-service HTTP calls required.
    Benefits: Real-time revocation, audit trail
    Tradeoff: ~50ms added latency per request
    {{/VALIDATION_METHOD_DATABASE}}
    {{#VALIDATION_METHOD_JWT}}
    Uses JWT decoding and signature verification.
    Requires shared JWT_SECRET between auth server and API.
    Benefits: Lower latency, stateless
    Tradeoff: No real-time revocation (valid until expiry)
    {{/VALIDATION_METHOD_JWT}}

    Args:
        credentials: HTTP Bearer token from Authorization header

    Returns:
        dict: User information (user_id, email, email_verified, status)

    Raises:
        HTTPException: If token is invalid or expired
    """
    token = credentials.credentials

    {{#VALIDATION_METHOD_DATABASE}}
    try:
        async with postgres_db.get_connection() as conn:
            async with conn.cursor() as cur:
                # Query user_sessions table directly for real-time validation
                await cur.execute(
                    """
                    SELECT s.user_id, u.email, u.status, u.email_verified
                    FROM user_sessions s
                    JOIN users u ON s.user_id = u.id
                    WHERE s.token = %s AND s.expires_at > NOW()
                    """,
                    (token,),
                )
                row = await cur.fetchone()

                if not row:
                    raise HTTPException(
                        status_code=status.HTTP_401_UNAUTHORIZED,
                        detail="Invalid or expired session token",
                        headers={"WWW-Authenticate": "Bearer"},
                    )

                # Return user information
                return {
                    "user_id": str(row["user_id"]),  # Ensure string for UUID
                    "email": row["email"],
                    "email_verified": row["email_verified"],
                    "status": row["status"],
                }

    except Exception as e:
        # If specific HTTPException, re-raise it
        if isinstance(e, HTTPException):
            raise e

        # Otherwise, generic auth error
        print(f"Auth Error: {e}")  # Log for debugging
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    {{/VALIDATION_METHOD_DATABASE}}

    {{#VALIDATION_METHOD_JWT}}
    try:
        # Decode and verify JWT token
        payload = jwt.decode(
            token,
            settings.JWT_SECRET,
            algorithms=[settings.JWT_ALGORITHM]
        )

        # Extract user information from token payload
        return {
            "user_id": payload.get("sub"),
            "email": payload.get("email"),
            "email_verified": payload.get("email_verified", False),
        }

    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.JWTError as e:
        print(f"JWT Error: {e}")  # Log for debugging
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    {{/VALIDATION_METHOD_JWT}}


async def get_current_active_user(
    current_user: Annotated[dict, Depends(get_current_user)],
) -> dict:
    """
    Get current active user (extends get_current_user with additional checks).

    Args:
        current_user: User information from token validation

    Returns:
        dict: Active user information

    Raises:
        HTTPException: If user is not active
    """
    # Add additional checks here if needed (e.g., check if user is suspended)
    if current_user.get("status") == "suspended":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is suspended",
        )

    return current_user


# Convenience type annotations
CurrentUser = Annotated[dict, Depends(get_current_user)]
CurrentActiveUser = Annotated[dict, Depends(get_current_active_user)]
