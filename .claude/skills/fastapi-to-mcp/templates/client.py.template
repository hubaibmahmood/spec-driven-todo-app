"""HTTP client for FastAPI backend communication

Generated: {{GENERATION_DATE}}

Pattern Support:
- Pattern 1-3: Simple HTTP client with auth headers/cookies
- Pattern 4: Service-to-service with retry logic and structured logging
"""

import httpx
from typing import Any, Optional, Dict
from datetime import datetime
import logging
from config import settings

# Optional: Import retry logic for Pattern 4 (microservices)
# Uncomment if using Pattern 4 service-to-service authentication
# from tenacity import (
#     retry,
#     stop_after_attempt,
#     wait_exponential,
#     retry_if_exception_type,
# )

logger = logging.getLogger(__name__)


class FastAPIClient:
    """Async HTTP client for FastAPI backend."""

    def __init__(self, base_url: str | None = None):
        """Initialize FastAPI client.

        Args:
            base_url: FastAPI base URL (defaults to settings.FASTAPI_BASE_URL)
        """
        self.base_url = base_url or settings.FASTAPI_BASE_URL

        # Configure HTTP client with connection pooling
        self.client = httpx.AsyncClient(
            base_url=self.base_url,
            timeout=httpx.Timeout(settings.FASTAPI_TIMEOUT),
            limits=httpx.Limits(
                max_keepalive_connections=settings.HTTP_MAX_KEEPALIVE,
                max_connections=settings.HTTP_MAX_CONNECTIONS,
                keepalive_expiry=settings.HTTP_KEEPALIVE_EXPIRY
            ),
            follow_redirects=True,
            http2=True  # Enable HTTP/2 for better performance
        )

        logger.info(f"FastAPI client initialized: {self.base_url}")

    def _get_auth_headers(self, user_id: str | None = None) -> Dict[str, str]:
        """Get authentication headers based on configured method.

        Args:
            user_id: User ID for JWT generation or service auth

        Returns:
            Dictionary of authentication headers
        """
        headers = {"Content-Type": "application/json"}

        if settings.AUTH_METHOD == "jwt" and settings.JWT_TOKEN:
            headers["Authorization"] = f"Bearer {settings.JWT_TOKEN}"
        elif settings.AUTH_METHOD == "jwt" and user_id:
            # TODO: Implement JWT generation if needed
            logger.warning("JWT generation not implemented, using token from config")
            if settings.JWT_TOKEN:
                headers["Authorization"] = f"Bearer {settings.JWT_TOKEN}"

        # Pattern 4: Service-to-service authentication
        # Uncomment if using microservices architecture
        # if settings.AUTH_METHOD == "service" and user_id:
        #     headers["Authorization"] = f"Bearer {settings.SERVICE_AUTH_TOKEN}"
        #     headers["X-User-ID"] = user_id

        return headers

    def _get_auth_cookies(self) -> Dict[str, str] | None:
        """Get authentication cookies based on configured method.

        Returns:
            Dictionary of cookies or None
        """
        if settings.AUTH_METHOD == "session" and settings.SESSION_TOKEN:
            return {settings.SESSION_COOKIE_NAME: settings.SESSION_TOKEN}
        return None

    async def get(
        self,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        user_id: Optional[str] = None
    ) -> Any:
        """GET request to FastAPI endpoint.

        Args:
            path: API endpoint path
            params: Query parameters
            headers: Additional headers
            user_id: User ID for authentication

        Returns:
            JSON response data

        Raises:
            httpx.HTTPStatusError: On HTTP errors
            httpx.RequestError: On connection errors
        """
        all_headers = {**self._get_auth_headers(user_id), **(headers or {})}
        cookies = self._get_auth_cookies()

        logger.debug(f"GET {path} params={params}")

        try:
            response = await self.client.get(
                path,
                params=params,
                headers=all_headers,
                cookies=cookies
            )
            response.raise_for_status()
            return response.json()

        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error on GET {path}: {e.response.status_code}")
            raise
        except httpx.RequestError as e:
            logger.error(f"Request error on GET {path}: {e}")
            raise

    async def post(
        self,
        path: str,
        json: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        user_id: Optional[str] = None
    ) -> Any:
        """POST request to FastAPI endpoint.

        Args:
            path: API endpoint path
            json: JSON request body
            params: Query parameters
            headers: Additional headers
            user_id: User ID for authentication

        Returns:
            JSON response data

        Raises:
            httpx.HTTPStatusError: On HTTP errors
            httpx.RequestError: On connection errors
        """
        all_headers = {**self._get_auth_headers(user_id), **(headers or {})}
        cookies = self._get_auth_cookies()

        logger.debug(f"POST {path} params={params} json={json}")

        try:
            response = await self.client.post(
                path,
                json=json,
                params=params,
                headers=all_headers,
                cookies=cookies
            )
            response.raise_for_status()
            return response.json()

        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error on POST {path}: {e.response.status_code} - {e.response.text}")
            raise
        except httpx.RequestError as e:
            logger.error(f"Request error on POST {path}: {e}")
            raise

    async def put(
        self,
        path: str,
        json: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        user_id: Optional[str] = None
    ) -> Any:
        """PUT request to FastAPI endpoint.

        Args:
            path: API endpoint path
            json: JSON request body
            params: Query parameters
            headers: Additional headers
            user_id: User ID for authentication

        Returns:
            JSON response data

        Raises:
            httpx.HTTPStatusError: On HTTP errors
            httpx.RequestError: On connection errors
        """
        all_headers = {**self._get_auth_headers(user_id), **(headers or {})}
        cookies = self._get_auth_cookies()

        logger.debug(f"PUT {path} params={params} json={json}")

        try:
            response = await self.client.put(
                path,
                json=json,
                params=params,
                headers=all_headers,
                cookies=cookies
            )
            response.raise_for_status()
            return response.json()

        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error on PUT {path}: {e.response.status_code}")
            raise
        except httpx.RequestError as e:
            logger.error(f"Request error on PUT {path}: {e}")
            raise

    async def delete(
        self,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        user_id: Optional[str] = None
    ) -> Any:
        """DELETE request to FastAPI endpoint.

        Args:
            path: API endpoint path
            params: Query parameters
            headers: Additional headers
            user_id: User ID for authentication

        Returns:
            JSON response data

        Raises:
            httpx.HTTPStatusError: On HTTP errors
            httpx.RequestError: On connection errors
        """
        all_headers = {**self._get_auth_headers(user_id), **(headers or {})}
        cookies = self._get_auth_cookies()

        logger.debug(f"DELETE {path} params={params}")

        try:
            response = await self.client.delete(
                path,
                params=params,
                headers=all_headers,
                cookies=cookies
            )
            response.raise_for_status()
            return response.json()

        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error on DELETE {path}: {e.response.status_code}")
            raise
        except httpx.RequestError as e:
            logger.error(f"Request error on DELETE {path}: {e}")
            raise

    async def patch(
        self,
        path: str,
        json: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        user_id: Optional[str] = None
    ) -> Any:
        """PATCH request to FastAPI endpoint.

        Args:
            path: API endpoint path
            json: JSON request body
            params: Query parameters
            headers: Additional headers
            user_id: User ID for authentication

        Returns:
            JSON response data

        Raises:
            httpx.HTTPStatusError: On HTTP errors
            httpx.RequestError: On connection errors
        """
        all_headers = {**self._get_auth_headers(user_id), **(headers or {})}
        cookies = self._get_auth_cookies()

        logger.debug(f"PATCH {path} params={params} json={json}")

        try:
            response = await self.client.patch(
                path,
                json=json,
                params=params,
                headers=all_headers,
                cookies=cookies
            )
            response.raise_for_status()
            return response.json()

        except httpx.HTTPStatusError as e:
            logger.error(f"HTTP error on PATCH {path}: {e.response.status_code}")
            raise
        except httpx.RequestError as e:
            logger.error(f"Request error on PATCH {path}: {e}")
            raise

    async def close(self):
        """Close HTTP client and cleanup connections."""
        await self.client.aclose()
        logger.info("FastAPI client closed")

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()


# ========================================
# Pattern 4: Service-to-Service Implementation
# ========================================
# Uncomment the following class if using Pattern 4 (microservices)
#
# class BackendClient:
#     """HTTP client with service-to-service auth and retry logic (Pattern 4)."""
#
#     def __init__(self):
#         self.base_url = settings.FASTAPI_BASE_URL
#         self.timeout = settings.BACKEND_TIMEOUT
#         self.client = httpx.AsyncClient(
#             base_url=self.base_url,
#             timeout=self.timeout,
#         )
#
#     def _build_headers(self, user_id: str) -> dict[str, str]:
#         """Build service auth headers with user context."""
#         return {
#             "Authorization": f"Bearer {settings.SERVICE_AUTH_TOKEN}",
#             "X-User-ID": user_id,
#             "Content-Type": "application/json",
#         }
#
#     @retry(
#         stop=stop_after_attempt(3),  # Initial + 2 retries
#         wait=wait_exponential(multiplier=1, min=1, max=2),  # 1s, 2s backoff
#         retry=retry_if_exception_type((httpx.TimeoutException, httpx.ConnectError)),
#         reraise=True,
#     )
#     async def _request(
#         self,
#         method: str,
#         endpoint: str,
#         user_id: str,
#         json: Optional[Dict[str, Any]] = None,
#     ) -> httpx.Response:
#         """Make HTTP request with retry logic and structured logging."""
#         start_time = datetime.now()
#         headers = self._build_headers(user_id)
#
#         try:
#             response = await self.client.request(
#                 method=method,
#                 url=endpoint,
#                 headers=headers,
#                 json=json,
#             )
#
#             duration_ms = (datetime.now() - start_time).total_seconds() * 1000
#
#             # Structured logging for audit trail
#             logger.info(
#                 "Backend API call completed",
#                 extra={
#                     "timestamp": datetime.now().isoformat(),
#                     "endpoint": endpoint,
#                     "method": method,
#                     "status_code": response.status_code,
#                     "user_id": user_id,
#                     "duration_ms": duration_ms,
#                 },
#             )
#
#             return response
#
#         except (httpx.TimeoutException, httpx.ConnectError) as e:
#             duration_ms = (datetime.now() - start_time).total_seconds() * 1000
#
#             logger.error(
#                 "Backend API call failed",
#                 extra={
#                     "timestamp": datetime.now().isoformat(),
#                     "endpoint": endpoint,
#                     "method": method,
#                     "user_id": user_id,
#                     "duration_ms": duration_ms,
#                     "error": str(e),
#                 },
#             )
#             raise
#
#     # Define endpoint-specific methods:
#     # async def get_tasks(self, user_id: str) -> httpx.Response:
#     #     return await self._request("GET", "/tasks/", user_id)
#     #
#     # async def create_task(self, user_id: str, task_data: dict) -> httpx.Response:
#     #     return await self._request("POST", "/tasks/", user_id, json=task_data)
#     #
#     # async def update_task(self, user_id: str, task_id: int, task_data: dict) -> httpx.Response:
#     #     return await self._request("PUT", f"/tasks/{task_id}", user_id, json=task_data)
#     #
#     # async def delete_task(self, user_id: str, task_id: int) -> httpx.Response:
#     #     return await self._request("DELETE", f"/tasks/{task_id}", user_id)
#
#     async def close(self):
#         """Close HTTP client connection."""
#         await self.client.aclose()
