"""MCP Tools generated from FastAPI endpoints

Auto-generated by fastapi-to-mcp Claude Code skill
Generated: {{GENERATION_DATE}}

Each tool corresponds to a FastAPI endpoint and maintains
the same request/response structure.

Total endpoints converted: {{TOOL_COUNT}}

Architecture Note:
- This file contains ALL tools in one file (monolithic approach)
- For microservices/Pattern 4: Consider splitting into separate files
  (e.g., src/tools/list_tasks.py, src/tools/create_task.py, etc.)
- Modular structure improves maintainability for 5+ tools
"""

from typing import Optional, List, Dict, Any
import logging
from mcp.server.fastmcp import FastMCP
from client import FastAPIClient
from config import settings
import httpx


logger = logging.getLogger(__name__)


def register_tools(mcp: FastMCP):
    """Register all FastAPI endpoints as MCP tools.

    Args:
        mcp: FastMCP server instance
    """
    # Initialize FastAPI client
    client = FastAPIClient()

    logger.info(f"Registering {{{TOOL_COUNT}}} tools from FastAPI endpoints...")

    {{TOOL_DEFINITIONS}}

    logger.info(f"âœ… Successfully registered {{{TOOL_COUNT}}} MCP tools")


# Error response helper
def _create_error_response(
    error_code: str,
    message: str,
    details: Optional[Dict[str, Any]] = None
) -> Dict[str, Any]:
    """Create standardized error response.

    Args:
        error_code: Error code (e.g., 'not_found', 'unauthorized')
        message: Human-readable error message
        details: Additional error details

    Returns:
        Error response dictionary
    """
    return {
        "status": "error",
        "error_code": error_code,
        "message": message,
        "details": details or {}
    }


# HTTP error handler
def _handle_http_error(e: httpx.HTTPStatusError) -> Dict[str, Any]:
    """Handle HTTP errors from FastAPI.

    Args:
        e: HTTP status error

    Returns:
        Error response dictionary
    """
    status_code = e.response.status_code

    error_map = {
        400: ("bad_request", "Invalid request data"),
        401: ("unauthorized", "Authentication required"),
        403: ("forbidden", "Access denied"),
        404: ("not_found", "Resource not found"),
        422: ("validation_error", "Validation failed"),
        500: ("server_error", "Internal server error"),
        502: ("bad_gateway", "FastAPI service unavailable"),
        503: ("service_unavailable", "Service temporarily unavailable"),
    }

    error_code, default_message = error_map.get(
        status_code,
        ("unknown_error", "Unexpected error")
    )

    try:
        error_detail = e.response.json().get("detail", default_message)
    except Exception:
        error_detail = e.response.text or default_message

    return _create_error_response(
        error_code=error_code,
        message=error_detail,
        details={"status_code": status_code}
    )


# Connection error handler
def _handle_connection_error(e: httpx.RequestError) -> Dict[str, Any]:
    """Handle connection errors to FastAPI.

    Args:
        e: Request error

    Returns:
        Error response dictionary
    """
    return _create_error_response(
        error_code="connection_error",
        message=f"Failed to connect to FastAPI: {str(e)}",
        details={
            "fastapi_url": settings.FASTAPI_BASE_URL,
            "exception": type(e).__name__
        }
    )
