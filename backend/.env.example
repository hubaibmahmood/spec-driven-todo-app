# Database Configuration
# Neon PostgreSQL connection string
# Format: postgresql+asyncpg://user:password@host/database
DATABASE_URL=postgresql+asyncpg://user:password@your-neon-endpoint.neon.tech/todo_db

# Authentication Configuration
# Shared secret for hashing session tokens (HMAC-SHA256)
# Must match the auth-server SESSION_HASH_SECRET
# Generate with: openssl rand -hex 32
SESSION_HASH_SECRET=your-secret-key-change-this-in-production
# URL of the auth server for integration tests

AUTH_SERVER_URL=http://localhost:8080

# Service-to-Service Authentication
# Token for authenticating requests from ai-agent microservice
# Must match SERVICE_AUTH_TOKEN in ai-agent/.env
# Generate with: openssl rand -hex 32
SERVICE_AUTH_TOKEN=your-service-auth-token-change-this

# Application Configuration
# Environment: development, staging, production
ENVIRONMENT=development

# CORS Configuration
# Comma-separated list of allowed origins
# Development: http://localhost:3000
# Production: https://yourdomain.com,https://www.yourdomain.com
CORS_ORIGINS=http://localhost:3000

# SQLAlchemy Connection Pool Settings
# Pool size: number of connections to keep open
SQLALCHEMY_POOL_SIZE=10
# Max overflow: additional connections allowed above pool_size
SQLALCHEMY_POOL_OVERFLOW=20
# Pool timeout: seconds to wait for available connection
SQLALCHEMY_POOL_TIMEOUT=30
# Pool recycle: seconds before recycling connections (Neon serverless)
SQLALCHEMY_POOL_RECYCLE=3600
# Echo SQL: log all SQL queries (development only)
SQLALCHEMY_ECHO=false

# Redis Configuration (for rate limiting)
# Redis connection URL
REDIS_URL=redis://localhost:6379/0

# API Key Encryption Configuration
# Fernet encryption key for encrypting user API keys at rest
# CRITICAL: Generate a new key for production with the command below
# Generate with: python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
# Store securely in secrets manager (AWS Secrets Manager, GitHub Secrets, etc.)
ENCRYPTION_KEY=your-fernet-encryption-key-change-this
