# Data Model: Hybrid JWT Authentication

**Feature**: 013-hybrid-jwt-auth
**Date**: 2026-01-02
**Status**: Complete

This document defines the data entities, structures, and validation rules for hybrid JWT authentication.

---

## 1. Access Token (JWT)

### Structure
**Type**: JSON Web Token (JWT)
**Storage**: Frontend (browser memory/localStorage)
**Lifetime**: 30 minutes
**Format**: Three base64url-encoded segments separated by dots: `header.payload.signature`

### JWT Header
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### JWT Payload (Claims)
```json
{
  "sub": "user_abc123",                    // Subject (user ID) - REQUIRED
  "iat": 1735862400,                       // Issued at (Unix timestamp) - REQUIRED
  "exp": 1735864200,                       // Expiration (Unix timestamp) - REQUIRED
  "type": "access"                         // Token type claim - REQUIRED
}
```

**Field Definitions**:
- `sub` (string): User ID from better-auth user table
- `iat` (integer): UTC timestamp when token was issued
- `exp` (integer): UTC timestamp when token expires (iat + 30 minutes)
- `type` (string): Token type discriminator, always "access"

**Validation Rules**:
- `sub` MUST be non-empty string
- `exp` MUST be greater than current time (not expired)
- `type` MUST equal "access" (prevents refresh token misuse as access token)
- Signature MUST be valid HMAC-SHA256 hash of header+payload with secret key
- Algorithm MUST be HS256 (prevents algorithm substitution attacks)

**State Transitions**: None (stateless, immutable after creation)

---

## 2. Refresh Token

### Structure
**Type**: Opaque cryptographically secure random string
**Storage**:
- Frontend: httpOnly cookie (browser-managed, cannot be accessed by JavaScript)
- Backend: SHA-256 hash in PostgreSQL `user_sessions` table
**Lifetime**: 7 days
**Format**: URL-safe base64 string (43 characters from 32 random bytes)

### Example
```
Plain token (sent in cookie): "q3rJ8xK2mP9vL5nB7dW1sA4fT6hY0cE8gU2iO5pR1vX"
Stored hash (in database):    "7f3a9b2c1e5d8f4a6b3c9e1d2f5a7b4c8e3d6f9a1b5c2e4d7f3a9b6c1e8d5f2a"
```

### Properties
- **Cryptographic randomness**: Generated via `secrets.token_urlsafe(32)` (Python) or `crypto.randomBytes(32).toString('base64url')` (Node.js)
- **One-way hashing**: SHA-256 hash prevents token recovery from database
- **Single-use validation**: Each refresh consumes the token (validates hash, then issues new token pair)
- **Revocation**: Delete database record to invalidate refresh token

**Validation Rules**:
- Token MUST be exactly 43 characters (32 bytes base64url)
- Hash in database MUST be 64 hex characters (SHA-256 output)
- `expires_at` MUST be greater than current UTC time
- `user_id` MUST reference existing user

**State Transitions**:
```
[Created] → (7 days pass) → [Expired]
[Created] → (user logs out) → [Revoked]
[Created] → (refresh endpoint called) → [Consumed & New Token Issued]
```

---

## 3. User Session Record (Database Entity)

### Table
**Name**: `user_sessions`
**Owner**: better-auth (Prisma-managed, shared with FastAPI)
**Purpose**: Store hashed refresh tokens with metadata

### Schema (Existing - No Migration Required)
```sql
CREATE TABLE user_sessions (
  id          VARCHAR(255) PRIMARY KEY,           -- CUID from better-auth
  userId      VARCHAR(255) NOT NULL,              -- Foreign key to users table
  token       VARCHAR(255) NOT NULL UNIQUE,       -- SHA-256 hash of refresh token
  expiresAt   TIMESTAMP WITHOUT TIME ZONE NOT NULL,
  ipAddress   TEXT,                               -- Client IP (audit trail)
  userAgent   TEXT,                               -- Client user agent (audit trail)
  createdAt   TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW(),
  updatedAt   TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_user_sessions_userId ON user_sessions(userId);
CREATE INDEX idx_user_sessions_expiresAt ON user_sessions(expiresAt);
```

### Field Definitions

| Field | Type | Nullable | Description | Validation |
|-------|------|----------|-------------|------------|
| `id` | VARCHAR(255) | NO | Primary key (CUID format) | Generated by better-auth or FastAPI |
| `userId` | VARCHAR(255) | NO | User ID reference | Must exist in users table |
| `token` | VARCHAR(255) | NO | SHA-256 hash (64 hex chars) | UNIQUE, exactly 64 characters |
| `expiresAt` | TIMESTAMP | NO | Expiration timestamp (UTC) | Must be > createdAt |
| `ipAddress` | TEXT | YES | Client IP address | IPv4 or IPv6 format |
| `userAgent` | TEXT | YES | HTTP User-Agent header | Max 1000 characters |
| `createdAt` | TIMESTAMP | NO | Record creation time | Auto-set to current UTC |
| `updatedAt` | TIMESTAMP | NO | Record update time | Auto-updated on modification |

### Indexes
- **Primary**: `id` (default)
- **Unique**: `token` (prevents duplicate hashes, enforces one token per hash)
- **Query**: `userId` (find all sessions for user)
- **Query**: `expiresAt` (cleanup expired sessions, validate token)

### Constraints
- `userId` references `users.id` (implicit - no FK due to better-auth management)
- `expiresAt > createdAt` (enforced in application logic)
- `token` length = 64 characters (enforced in application logic)

### Relationships
```
users (better-auth managed)
  └─ one-to-many → user_sessions
```

**Note**: This table is shared between better-auth (Node.js) and FastAPI (Python). Both systems write to it:
- better-auth: Writes session tokens (plain format) during login via its own session management
- FastAPI (JWT): Writes refresh token hashes (SHA-256) during JWT-based login

---

## 4. Token Pair (Composite Entity)

### Structure
**Type**: Composite object returned from login/signup and token refresh endpoints
**Purpose**: Contains both access token (JWT) and refresh token (opaque string)

### JSON Response Format
```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyX2FiYzEyMyIsImlhdCI6MTczNTg2MjQwMCwiZXhwIjoxNzM1ODY0MjAwLCJ0eXBlIjoiYWNjZXNzIn0.S2lkbmV5X1N0b25lc19BcmVfUGFpbmZ1bA",
  "refreshToken": "q3rJ8xK2mP9vL5nB7dW1sA4fT6hY0cE8gU2iO5pR1vX",
  "expiresIn": 1800  // Access token expiration in seconds (30 minutes)
}
```

**Field Definitions**:
- `accessToken` (string): JWT in compact serialization format
- `refreshToken` (string): Opaque refresh token (NOT returned by refresh endpoint - sent in httpOnly cookie only)
- `expiresIn` (integer): Access token lifetime in seconds

**Validation Rules**:
- `accessToken` MUST be valid JWT format (3 base64url segments)
- `refreshToken` MUST be 43 characters (when returned from login/signup)
- `expiresIn` MUST equal 1800 (30 minutes * 60 seconds)

**Delivery Methods**:
- **Login/Signup Response**: Both tokens in JSON body + refresh token in httpOnly cookie
- **Refresh Endpoint Response**: Only `accessToken` in JSON body (refresh token already in cookie)

---

## 5. Authentication State Machine

### States
1. **Unauthenticated**: No valid access token or refresh token
2. **Authenticated (JWT)**: Valid access token, valid refresh token
3. **Authenticated (Session)**: Valid session token (legacy better-auth session)
4. **Expired Access Token**: Access token expired, refresh token valid (triggers auto-refresh)
5. **Expired Refresh Token**: Both tokens expired (requires re-login)

### State Diagram
```
[Unauthenticated]
    ↓ login/signup
[Authenticated (JWT)]
    ↓ 30 minutes pass
[Expired Access Token]
    ↓ refresh endpoint call
[Authenticated (JWT)]
    ↓ 7 days pass OR logout
[Unauthenticated]

[Authenticated (Session)] ← existing better-auth flow (gradual migration)
```

### Transitions

| From State | Event | To State | Action |
|------------|-------|----------|--------|
| Unauthenticated | Login/Signup | Authenticated (JWT) | Issue token pair, store refresh hash in DB |
| Authenticated (JWT) | API request (token valid) | Authenticated (JWT) | Validate JWT signature, allow request |
| Authenticated (JWT) | 30 min pass | Expired Access Token | Access token expires, refresh token still valid |
| Expired Access Token | Refresh endpoint call | Authenticated (JWT) | Validate refresh token, issue new access token |
| Authenticated (JWT) | Logout | Unauthenticated | Delete refresh token from DB, clear cookies |
| Expired Access Token | 7 days pass | Expired Refresh Token | Refresh token expires in DB |
| Expired Refresh Token | Any API request | Unauthenticated | Return 401, redirect to login |
| Authenticated (Session) | API request | Authenticated (Session) | Validate session in DB (existing flow) |

---

## 6. API Request/Response Models

### 6.1 POST /api/auth/refresh

**Request** (httpOnly cookie):
```
Cookie: refreshToken=q3rJ8xK2mP9vL5nB7dW1sA4fT6hY0cE8gU2iO5pR1vX
```

**Successful Response (200 OK)**:
```json
{
  "accessToken": "eyJhbGc...",
  "expiresIn": 1800
}
```

**Error Responses**:

*401 Unauthorized - Expired Refresh Token*:
```json
{
  "error": "refresh_token_expired",
  "message": "Your session has expired. Please log in again."
}
```

*401 Unauthorized - Invalid Refresh Token*:
```json
{
  "error": "invalid_refresh_token",
  "message": "Invalid refresh token."
}
```

*401 Unauthorized - Revoked Session*:
```json
{
  "error": "session_revoked",
  "message": "Your session has been terminated. Please log in again."
}
```

*500 Internal Server Error - Database Error*:
```json
{
  "error": "internal_error",
  "message": "Unable to refresh token. Please try again."
}
```

### 6.2 POST /api/auth/logout

**Request** (Authorization header):
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Successful Response (200 OK)**:
```json
{
  "message": "Logged out successfully"
}
```

**Error Response (401 Unauthorized)**:
```json
{
  "error": "unauthorized",
  "message": "Invalid or expired token"
}
```

---

## 7. Data Validation Summary

### Access Token Validation
```python
# Pseudocode
def validate_access_token(token: str) -> str:
    """Validate JWT access token and return user ID."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])

        # Validate claims
        assert payload.get("type") == "access", "Invalid token type"
        assert payload.get("sub"), "Missing user ID"
        assert payload.get("exp") > current_utc_timestamp(), "Token expired"

        return payload["sub"]
    except jwt.ExpiredSignatureError:
        raise TokenExpiredError("Access token expired")
    except jwt.InvalidTokenError as e:
        raise InvalidTokenError(f"Invalid token: {e}")
```

### Refresh Token Validation
```python
# Pseudocode
def validate_refresh_token(token: str, db: Session) -> str:
    """Validate refresh token hash against database and return user ID."""
    # Hash incoming token
    token_hash = sha256(token).hexdigest()

    # Query database (constant-time hash comparison)
    session = db.query(UserSession).filter(
        UserSession.token == token_hash,
        UserSession.expires_at > current_utc_timestamp()
    ).first()

    if not session:
        raise InvalidRefreshTokenError("Invalid or expired refresh token")

    return session.user_id
```

---

## Summary

| Entity | Storage | Lifetime | Validation Method | Purpose |
|--------|---------|----------|-------------------|---------|
| Access Token (JWT) | Frontend (memory/localStorage) | 30 minutes | Signature verification (no DB) | Authorize API requests |
| Refresh Token | Frontend (httpOnly cookie) + DB (hashed) | 7 days | Hash comparison in DB | Obtain new access tokens |
| User Session Record | PostgreSQL (user_sessions table) | 7 days | Expiration timestamp check | Track active sessions, enable revocation |
| Token Pair | API response (JSON) | N/A | Component validation | Return both tokens from login/refresh |

**Data Flow**:
1. Login → Issue access token (JWT) + refresh token (random) → Store refresh hash in DB
2. API Request → Validate JWT signature (no DB lookup)
3. Access Token Expires → Auto-refresh via refresh endpoint → Validate refresh hash in DB → Issue new access token
4. Logout → Delete refresh hash from DB → Tokens invalidated

**No complex validation rules or state machines required.** Standard JWT + refresh token pattern with proven security practices.
